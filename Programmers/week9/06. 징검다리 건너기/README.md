https://school.programmers.co.kr/learn/courses/30/lessons/64062


## 재정의
- 디딤돌의 숫자는 한 번 밟을때 1씩 줄어든다.
- 숫자가 0이 되면 밟을 수 없다ㅏ.
- 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가까운 디딤돌만 건널 수 있다.
- stones : 디딤돌에 적힌 수가 담긴 배열
- k : 한 번에 건너뛸 수 있는 디딤 돌의 최대 칸 수
- 최대 몇 명까지 징검다리를 건널 수 있는가?

#### [제한사항]
- 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한
- stones 배열의 크기는 1 이상 200,000 이하
- stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수
- k는 1 이상 stones의 길이 이하인 자연수


<br><br>
<br>

## 알고리즘
#### 방법1
1. 돌의 숫자가 0보다 크면 -1 차감하고 건넌다.
2. 돌의 숫자가 0이면 건너 뛰고 건너 뛴 수를 증가시킨다.
  - 이전에도 돌을 건너뛰었는지 확인할 수 있어야 한다.
3. 최 대 칸 수 K 를 넘어서 뛸 수 없다.
4. 건너뛴 칸 수가 >= k이면 끝


#### 시간복잡도
- while 문을 사용하기 때문에 최악의 경우 O(max(stones))
- 내부 for문 stones.length 만큼
- 따라서 O(max(stones) * stones.length)
#### 공간 복잡도
- 입력 배열 외 필요한 공간, 정수형 변수가 모두 상숫 공간을 차지하기 때문에 O(1)

<br><br>

-> 이 문제는 배열의 크기와, 돌의 값이 크기 때문에 이진 탐색을 사용해야 한다.  
#### 방법2
1. left는 최소 건널 수 있는 인원 1, right는 최대 인원 최댓값(stones).
2. 중간 값(mid)을 사용하여 이 사람이 건널 수 있는지 확인
3. 각 돌에서 mid 명이 건너면 돌의 값이 mid 이상인 돌은 건널 수 있지만, 그렇지 않은 돌은 0으로 간주하여 연속된 0이 k 이상인 구간이 생기면 mid 명은 건널 수 없다고 판단

#### 시간 복잡도
- 이진 탐색으로 left와 right 범위는 최대값이 **max(stones)**이므로, 이진 탐색의 반복 횟수는 **O(log(max(stones)))**
- canCross 함수: 이진 탐색의 각 단계에서 canCross 함수는 stones.length 크기 배열을 한 번 순회하여 건널 수 있는지 검사한다, O(stones.length)
- 따라서 O(stones.length * log(max(stones)))

#### 공간 복잡도
정수형 변수는 모두 상수 공간을 차지하 때문에 **O(1)**

<br><br><br>

## 의사코드
```
int num;
int[] newStones
while (건너뛴 칸 수의 최대가 < k) {
    int maxK = 0
    canCross 이전에 뛰었는지

    for (징검다리) {
        if (0이면) {
            건너 뛰기maxK++;
        }
        숫자 카운트 -1;
    }
    

    건넌 사람 증가 num++;
}

return num;
```
<br><br><br>


## 구현
