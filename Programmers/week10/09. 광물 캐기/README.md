https://school.programmers.co.kr/learn/courses/30/lessons/172927

## 재정의
- 다이아몬드, 철, 돌 곡괭이 각각 0~5개 까지 갖는다.
- 곡괭이 광물 캘 때 피로도가 소모된다.
<img width="485" alt="image" src="https://github.com/user-attachments/assets/b35e4e04-ecba-4ce0-8475-b71750cadfd9">

- 사용할 수 있는 곡괭이 중 아무거나 선택해 광물을 캔다.
- 한 번 사용 시작한 곡괭이는 사용할 수 없을 때까지 사용한다.
- 광물은 주어진 순서로 캘 수 있다.
- 광산에 있는 모든 광물을 캐거나, 더 사용할 곡괭이가 없을 때까지 광물을 캔다.
- 최소한의 피로도를 return 




<br><br><br>

## 알고리즘
미리 피로도에 대한 정보를 배열로 정렬한다. 
0. 다이아 -> 철 -> 돌 순으로 작업하는 것이 가장 피로도가 낮다. 곡괭이 하나로 광물 다섯개 캘 수 있음..!

1. 곡괭이 하나로 광물 다섯개씩 캐기 때문에 그룹을 먼저 만든다.
2. 하나의 그룹을 다이아몬드/철/돌 곡괭이를 사용했을때의 피로도를 그룹별로 리스트에 저장한다.
3. 광석?그룹을 피로도(최악의 경우) 기준으로 내림차순 정렬한다. (다이아 몬드> 철 > 돌 순으로 사용하기 위해)
4. 정렬된 순서대로 현재 가지고 있는 가장 최선의 곡괭이를 사용했을 때의 피로도를 저장한다.



<br>

테스트 케이스 8번을 계속 실패한다면, 아래를 확인하자.   
**곡갱이 개수가 부족하면 광물 전체가 아니라 팔 수 있는 광물까지만 sort해야한다.**



#### 시간 복잡도
- 광물 그룹 : 광물 배열을 5개씩 그룹으로 나누는 과정으로. n/5개의 그룹을 만든다, **O(n)**   
- 정렬 : mineralGroups 피로도 기준으로 내림차순 정렬
- 그룹의 개수가 n/5일 때 -> **O((n/5) * log(n/5)) = O(n log n)**
- 피로도 계산 : 광물 그룹의 수(n/5)만큼 반복, **O(n)**
- O(n log n)

#### 공간 복잡도
- mineralGroups : n/5
- 그 외는 상수값을 갖는다.
- O(n)


<br><br><br>


## 의사코드
```
stress 2차원 배열 생성 

* maxpicks 최대 곡괭이의 개수
mineralgroups 광물 그룹(5개씩)
곡괭이 만큼만 광물 팔 수 있음
for (mineral = 0; i < Math.min(maxpicks,광물개수), i+=5) {
    그룹화
}

피로도 순으로 내림차순정렬
mineralGroups.sort


피로도 누적 계산
stressScore = 0
for(mineralGroups) {
  for 곡괭이 종류별로 돌기 {
      사용할 곡괭이 고르고
      stressScore += 피로도
  } 

}
return stressScore
```




<br><br><br>



## 구현
