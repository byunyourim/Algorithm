https://school.programmers.co.kr/learn/courses/30/lessons/131130

## 재정의
- 범희는.. 혼자 잘 논다..
- 카드 100장
- 자연수를 하나 정해, 그 수보다 작거나 같은 숫자 카드를 준비한다.
- 준비한 카드의 수만큼 작은 상자를 준비하면 게임 시작이다.

<br>

0. 카드를 넣은 상자를 무작위로 섞어 일렬로 나열하고, 나열된 순서에 따라 1번 부터 순차적으로 번호를 부여한다. (1, 2, 3, ....)
1. 임의의 상자를 하나 선택하여 카드를 확인한다.
2. 카드에 적힌 번호에 해당하는 상자를 열어서 카드를 확인한다.
3. 1~2 반복한다.
4. 열어야 하는 상자가 이미 열려있을 때까지 반복
5. 여기까지가 1번 상자 그룹이다.
6. 남은 상자가 없을 때까지 1~5 과정 반복

<br>
   
- 게임의 점수 : 1번 그룹의 상자 수 * 2번 그룹의 상자수
- 1번 그룹만 있는 경우 획득하는 점수 = 0
- 얻을 수 있는 최고 점수 구하기.


<br><br>

## 알고리즘
0. DFS/ BFS 이용
1. 카드 배열, 그룹별 상자 크기 리스트 생성
2. for문 카드 리스트 (상자 나열~)
   - 상자 그룹 찾기 (findGroupSize())
   - 상자 그룹의 크기 리스트에 추가
3. findGroupSize 상자 그룹 크기 찾기
   - 현재 인덱스 (= 상자의 번호 - 1)
   - 열지않은 상자인 경우만 열어본다. while
   - 다음에 열어볼 상자번호 = 카드의 수 - 1; // 배열의 인덱스 0부터 시작하므로
   - 박스의 수 증가
4. 상자 그룹의 크기 리스트 내림차순으로 정렬 (1번 그룹과 2번 그룹의 곱이 최대가 되도록) 
3. return 게임 점수 

#### 시간 복잡도
- 최대 카드의 크기만큼? for문 순회 O(N), N은 카드 배열의 길이
- 박스를 모두 한 번씩 방문하여 방문 여부를 처리 O(N)
- 따라서, O(N)


#### 공간 복잡도
- 방문 여부를 확인하는 배열 O(N)
- 상자 그룹의 사이즈리스트는 최악의 경우 O(N)
- 따라서, O(N)
<br><br>


## 의사코드
```
1. 박스에 값 넣기
int[][] boxs = new int[cards.length][2];
for () {
    boxs = new int {};
}

2. 박스의 번호로 정렬

3. while (박스가 있을 때) {

    (1) 첫 번째 상자 번호와 같은 카드 번호를 갖는 상자번호..

    (2) 방문 한 곳인 경우 종료

    (3) 방문 완료 처리

    (4) 상자 개수 카운트
}
```



<br><br>

## 구현
