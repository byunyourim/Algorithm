https://school.programmers.co.kr/learn/courses/30/lessons/140107


## 재정의
- (0,0) 으로부터 x 축 방향으로 a * k, y 축 방향으로 b * k 만큼 떨어진 위치에 점을 찍는다.
- 원점과 거리가 d를 넘는 위치에는 점을 찍지 않는다.
  - **ak^2 + bk^2 <= d^2**
- K와 원점과의 거리를 나타내는 정수 d가 주어졌을 때, 점이 총 몇 개 찍히는지 return
- 좌표의 개수 구하기
- k는 양의 정수, a와 b도 0부터이므로 제 1사분면에서 찍히는 개수를 구하면 된다~



<br><br>

## 알고리즘
0. 1사분면 위에 있는 좌표의 개수 구하기
1. 최대 거리값 d를 넘지 않을 때까지 0부터 시작하여 k씩 더해주며 x를 증가시킨다.
2. maxY값을 구한다.
3. cnt에  maxY / k + 1을 더한다. 

#### 시간 복잡도
- 반지름의 길이를 k의 간격만큼 반복한다. O(d/k)
- k를 상수로 취급하여, 최악의 경우 O(d)

#### 공간 복잡도
- 변수 cnt나 maxY와 같은 계산 결과만 사용하므로 상수값의 공간을 차지한다.
- O(1)

<br><br>

## 의사코드
```
int cnt = 0;

for (x = 0 ; x <= d; x++) {
    int y = Math.floor(Math.sqrt(d^2 - x^2));

    2. k 간격인 경우, 0부터 시작이므로 1을 더함
    maxIndex = maxY / k + 1
}
return cnt;
```



<br><br>

## 구현

