https://school.programmers.co.kr/learn/courses/30/lessons/132266

## 재정의
- 두 지역 간 길을 통과하는 데 걸리는 시간은 1시간으로 동일하다.
- 최단 시간으로 부대에 복귀
- 경로가 없어질 수 있음..
- n : 강철부대가 위치한 지역을 포함한 총 지역 수
- roads : 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열
- sources : 각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열
- destination : 강철부대의 지역
- 복귀가 불가능한 경우 해당 부대원의 최단시간은 -1이다.






## 알고리즘
- 가장 먼저 최단 거리를 구하는데 가중치가 동일하다.
- 그리고 여러 곳에서 목적지(destination)로 가는 것으로
- 반대로 destination이 하나이기 때문에 출발지로 설정하여 갈 수 있다.
- 따라서 bfs를 이용하였다. 
  
- 시작노드 destination부터 sources까지 가는 최단 거리 구하기


<br>
<br>

1. 그래프를 그린다. 인접 리스트 이용
2. 최단 거리 distance[] 초기화 (출발 지역 : 0, 나머지 : -1)
3. 출발지역 방문 큐에 넣기
4. 현재 방문 지역 큐에서 빼고, 연결된 곳 큐에 넣기
5. 반복, 횟수 배열에 넣기
6. 결과 배열 리턴


#### 시간 복잡도: O(V + E)
- 각 노드는 한 번, 간선도 한 번만 방문한다.

#### 공간 복잡도: O(V + E)
- 인접 리스트, 거리 배열, 큐의 공간이 V와 E에 비례한다.
- 인접 리스트는 노드에 연결된 간선을 리스트 형태로 저장 O(E)
- 거리배열과 큐는 노드의 수만큼 저장된다. 각 O(V)


## 의사코드
생략



## 구현 



