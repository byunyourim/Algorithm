## 벨만-포드



그래프에서 **한 정점에서 다른 모든 정점까지의 최단 경로를 찾는 알고리즘**으로, 음수 가중치가 있는 그래프에서 사용할 수 있다.   



**모든 간선을 반복적으로 확인하면서 경로를 업데이트해 나가는 방식**으로, 출발점에서 다른 노드로 가는 최단 경로를 찾기 위해, 연결된 모든 경로를 여러 번 탐색하고 최적의 경로가 있는지 확인한다.

<br>




#### 필요한 변수
- 최단 경로 배열 distance 생성
- Edge Class {출발, 종료, 가중치}
- 최단거리 리스트에서 업데이트 반복 횟수는 노드 개수 - 1  
    -  A노드에서 B C노드를 거쳐 D 노드까지 도달하는 경우 Edge의 개수는 A - B, B - C, C - D로 3개이다.
    - 따라서 N개의 노드에서 에지의 최대 개수는 N -1개이다. 


#### 업데이트 조건(방법)

출발 노드가 무한대 일 경우에는 건너뛰고,

도착노드의 최단경로 값 > (출발노드의 최단경로 값  + 두 노드를 잇는 간선의 가중치) 인 경우 업데이트

```
if(distance[출발 노드] == 무한대){
	continue;
}
if(distance[도착 노드] > distance[출발 노드] + 간선 가중치 ){
	distance[도착 노드] = distance[출발 노드] + 간선 가중치;
}
```


<br>

## 벨만-포드 알고리즘의 동작 방식


1. 출발 노드를 0으로 설정, 나머지 노드 무한으로 설정
2. 모든 간선을 V-1 반복하며, 간선 갱신
3. V-1 반복 후, 한 번 더 모든 간선을 확인하여 음의 사이클이 존재하는지 검사한다.
4. 음의 사이클 여부 확인 후 최단 거리 계산 완료


벨만-포드는 모든 간선을 반복적으로 확인하고, 음의 가중치를 처리할 수 있지만, 시간 복잡도가 더 크다.




    
벨만-포드 알고리즘은 모든 간선을 V-1번 반복하면서 확인하기 때문에 **O(V * E)**의 시간 복잡도를 갖는데, 노드가 많을수록 느려질 수 있다.  



```java
public int[] bellmanford(int n, int[][] edges) {
        int[] dist = new int[];
        Arrays.fill(dist, Integer.MAX_VALUE);
        
        for (int i = 0; i < n - 1; i++) {
            for (int[] edge : edges) {
                int u = edge[0];
                int v = edge[1];
                int w = edge[2];
                
                if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                }
            }
        }
        
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int w = edge[2];
            if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {
                return new int[0];
            }
        }
    }
```

