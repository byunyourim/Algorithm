## 벨만-포드



그래프에서 **한 정점에서 다른 모든 정점까지의 최단 경로를 찾는 알고리즘**으로, 음수 가중치가 있는 그래프에서 사용할 수 있다.   



**모든 간선을 반복적으로 확인하면서 경로를 업데이트해 나가는 방식**으로, 출발점에서 다른 노드로 가는 최단 경로를 찾기 위해, 연결된 모든 경로를 여러 번 탐색하고 최적의 경로가 있는지 확인한다.

<br>




#### 필요한 변수
- 최단 경로 배열 distance 생성
- Edge Class {출발, 종료, 가중치}
- 최단거리 리스트에서 업데이트 반복 횟수는 노드 개수 - 1  
    -  A노드에서 B C노드를 거쳐 D 노드까지 도달하는 경우 Edge의 개수는 A - B, B - C, C - D로 3개이다.
    - 따라서 N개의 노드에서 에지의 최대 개수는 N -1개이다. 


#### 업데이트 조건(방법)

출발 노드가 무한대 일 경우에는 건너뛰고,

도착노드의 최단경로 값 > (출발노드의 최단경로 값  + 두 노드를 잇는 간선의 가중치) 인 경우 업데이트

```
if(distance[출발 노드] == 무한대){
	continue;
}
if(distance[도착 노드] > distance[출발 노드] + 간선 가중치 ){
	distance[도착 노드] = distance[출발 노드] + 간선 가중치;
}
```


<br>

## 벨만-포드 알고리즘의 동작 방식


1. 시작점 선택: 출발점을 선택하고, 그 점에서부터의 거리를 0으로 설정한다.
2. 경로 업데이트: 모든 간선을 확인하면서, 어떤 간선을 거쳐가는 것이 더 짧은 경로라면 해당 거리를 업데이트해. 이를 그래프에 있는 모든 간선에 대해 노드 수 - 1번 반복한다.
3. 음수 사이클 확인: **마지막에 한 번 더 모든 간선을 확인해서**, 만약 더 짧은 경로로 업데이트되는 노드가 있으면 음수 사이클이 있는 것으로 판단할 수 있다. **(음수 사이클이 있다면, 최단 경로를 찾을 수 없어.)**

- 음수 사이클은 해당 사이클을 돌았을 때 가중치 값이 줄어드는 것이다.


- 정점을 중복으로 거치지 않기 위해서 v-1만큼 반복하낟.

벨만-포드는 다익스트라 알고리즘처럼 빠르지는 않지만, 음수 가중치가 포함된 그래프에서도 안정적으로 최단 경로를 찾아낼 수 있다.




    
벨만-포드 알고리즘은 모든 간선을 V-1번 반복하면서 확인하기 때문에 **O(V * E)**의 시간 복잡도를 갖는데, 노드가 많을수록 느려질 수 있다.  


